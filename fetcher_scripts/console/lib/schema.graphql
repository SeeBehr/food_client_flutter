schema {
  query: query_root
  mutation: mutation_root
  subscription: subscription_root
}

"""whether this query should be cached (Hasura Cloud only)"""
directive @cached(
  """measured in seconds"""
  ttl: Int! = 60

  """refresh the cache entry"""
  refresh: Boolean! = false
) on QUERY

"""
Boolean expression to compare columns of type "Int". All fields are combined with logical 'AND'.
"""
input Int_comparison_exp {
  _eq: Int
  _gt: Int
  _gte: Int
  _in: [Int!]
  _is_null: Boolean
  _lt: Int
  _lte: Int
  _neq: Int
  _nin: [Int!]
}

"""
Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'.
"""
input String_comparison_exp {
  _eq: String
  _gt: String
  _gte: String

  """does the column match the given case-insensitive pattern"""
  _ilike: String
  _in: [String!]

  """
  does the column match the given POSIX regular expression, case insensitive
  """
  _iregex: String
  _is_null: Boolean

  """does the column match the given pattern"""
  _like: String
  _lt: String
  _lte: String
  _neq: String

  """does the column NOT match the given case-insensitive pattern"""
  _nilike: String
  _nin: [String!]

  """
  does the column NOT match the given POSIX regular expression, case insensitive
  """
  _niregex: String

  """does the column NOT match the given pattern"""
  _nlike: String

  """
  does the column NOT match the given POSIX regular expression, case sensitive
  """
  _nregex: String

  """does the column NOT match the given SQL regular expression"""
  _nsimilar: String

  """
  does the column match the given POSIX regular expression, case sensitive
  """
  _regex: String

  """does the column match the given SQL regular expression"""
  _similar: String
}

"""
columns and relationships of "bridge_recipes_cuisines"
"""
type bridge_recipes_cuisines {
  _cuisine_id: String!
  _recipe_id: String!

  """An object relationship"""
  cuisines: cuisines
  id: uuid!

  """An object relationship"""
  recipes: recipes
}

"""
aggregated selection of "bridge_recipes_cuisines"
"""
type bridge_recipes_cuisines_aggregate {
  aggregate: bridge_recipes_cuisines_aggregate_fields
  nodes: [bridge_recipes_cuisines!]!
}

input bridge_recipes_cuisines_aggregate_bool_exp {
  count: bridge_recipes_cuisines_aggregate_bool_exp_count
}

input bridge_recipes_cuisines_aggregate_bool_exp_count {
  arguments: [bridge_recipes_cuisines_select_column!]
  distinct: Boolean
  filter: bridge_recipes_cuisines_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "bridge_recipes_cuisines"
"""
type bridge_recipes_cuisines_aggregate_fields {
  count(columns: [bridge_recipes_cuisines_select_column!], distinct: Boolean): Int!
  max: bridge_recipes_cuisines_max_fields
  min: bridge_recipes_cuisines_min_fields
}

"""
order by aggregate values of table "bridge_recipes_cuisines"
"""
input bridge_recipes_cuisines_aggregate_order_by {
  count: order_by
  max: bridge_recipes_cuisines_max_order_by
  min: bridge_recipes_cuisines_min_order_by
}

"""
input type for inserting array relation for remote table "bridge_recipes_cuisines"
"""
input bridge_recipes_cuisines_arr_rel_insert_input {
  data: [bridge_recipes_cuisines_insert_input!]!

  """upsert condition"""
  on_conflict: bridge_recipes_cuisines_on_conflict
}

"""
Boolean expression to filter rows from the table "bridge_recipes_cuisines". All fields are combined with a logical 'AND'.
"""
input bridge_recipes_cuisines_bool_exp {
  _and: [bridge_recipes_cuisines_bool_exp!]
  _cuisine_id: String_comparison_exp
  _not: bridge_recipes_cuisines_bool_exp
  _or: [bridge_recipes_cuisines_bool_exp!]
  _recipe_id: String_comparison_exp
  cuisines: cuisines_bool_exp
  id: uuid_comparison_exp
  recipes: recipes_bool_exp
}

"""
unique or primary key constraints on table "bridge_recipes_cuisines"
"""
enum bridge_recipes_cuisines_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  bridge_recipes_cuisines_pkey
}

"""
input type for inserting data into table "bridge_recipes_cuisines"
"""
input bridge_recipes_cuisines_insert_input {
  _cuisine_id: String!
  _recipe_id: String!
  cuisines: cuisines_obj_rel_insert_input
  id: uuid
  recipes: recipes_obj_rel_insert_input
}

"""aggregate max on columns"""
type bridge_recipes_cuisines_max_fields {
  _cuisine_id: String
  _recipe_id: String
  id: uuid
}

"""
order by max() on columns of table "bridge_recipes_cuisines"
"""
input bridge_recipes_cuisines_max_order_by {
  _cuisine_id: order_by
  _recipe_id: order_by
  id: order_by
}

"""aggregate min on columns"""
type bridge_recipes_cuisines_min_fields {
  _cuisine_id: String
  _recipe_id: String
  id: uuid
}

"""
order by min() on columns of table "bridge_recipes_cuisines"
"""
input bridge_recipes_cuisines_min_order_by {
  _cuisine_id: order_by
  _recipe_id: order_by
  id: order_by
}

"""
response of any mutation on the table "bridge_recipes_cuisines"
"""
type bridge_recipes_cuisines_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [bridge_recipes_cuisines!]!
}

"""
on_conflict condition type for table "bridge_recipes_cuisines"
"""
input bridge_recipes_cuisines_on_conflict {
  constraint: bridge_recipes_cuisines_constraint!
  update_columns: [bridge_recipes_cuisines_update_column!]! = []
  where: bridge_recipes_cuisines_bool_exp
}

"""Ordering options when selecting data from "bridge_recipes_cuisines"."""
input bridge_recipes_cuisines_order_by {
  _cuisine_id: order_by
  _recipe_id: order_by
  cuisines: cuisines_order_by
  id: order_by
  recipes: recipes_order_by
}

"""primary key columns input for table: bridge_recipes_cuisines"""
input bridge_recipes_cuisines_pk_columns_input {
  id: uuid!
}

"""
select columns of table "bridge_recipes_cuisines"
"""
enum bridge_recipes_cuisines_select_column {
  """column name"""
  _cuisine_id

  """column name"""
  _recipe_id

  """column name"""
  id
}

"""
input type for updating data in table "bridge_recipes_cuisines"
"""
input bridge_recipes_cuisines_set_input {
  _cuisine_id: String
  _recipe_id: String
  id: uuid
}

"""
Streaming cursor of the table "bridge_recipes_cuisines"
"""
input bridge_recipes_cuisines_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: bridge_recipes_cuisines_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input bridge_recipes_cuisines_stream_cursor_value_input {
  _cuisine_id: String
  _recipe_id: String
  id: uuid
}

"""
update columns of table "bridge_recipes_cuisines"
"""
enum bridge_recipes_cuisines_update_column {
  """column name"""
  _cuisine_id

  """column name"""
  _recipe_id

  """column name"""
  id
}

input bridge_recipes_cuisines_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: bridge_recipes_cuisines_set_input
  where: bridge_recipes_cuisines_bool_exp!
}

"""
columns and relationships of "bridge_recipes_ingredients"
"""
type bridge_recipes_ingredients {
  _ingredient_id: String!
  _recipe_id: String!
  id: uuid!

  """An object relationship"""
  ingredients: ingredients

  """An object relationship"""
  recipes: recipes
}

"""
aggregated selection of "bridge_recipes_ingredients"
"""
type bridge_recipes_ingredients_aggregate {
  aggregate: bridge_recipes_ingredients_aggregate_fields
  nodes: [bridge_recipes_ingredients!]!
}

input bridge_recipes_ingredients_aggregate_bool_exp {
  count: bridge_recipes_ingredients_aggregate_bool_exp_count
}

input bridge_recipes_ingredients_aggregate_bool_exp_count {
  arguments: [bridge_recipes_ingredients_select_column!]
  distinct: Boolean
  filter: bridge_recipes_ingredients_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "bridge_recipes_ingredients"
"""
type bridge_recipes_ingredients_aggregate_fields {
  count(columns: [bridge_recipes_ingredients_select_column!], distinct: Boolean): Int!
  max: bridge_recipes_ingredients_max_fields
  min: bridge_recipes_ingredients_min_fields
}

"""
order by aggregate values of table "bridge_recipes_ingredients"
"""
input bridge_recipes_ingredients_aggregate_order_by {
  count: order_by
  max: bridge_recipes_ingredients_max_order_by
  min: bridge_recipes_ingredients_min_order_by
}

"""
input type for inserting array relation for remote table "bridge_recipes_ingredients"
"""
input bridge_recipes_ingredients_arr_rel_insert_input {
  data: [bridge_recipes_ingredients_insert_input!]!

  """upsert condition"""
  on_conflict: bridge_recipes_ingredients_on_conflict
}

"""
Boolean expression to filter rows from the table "bridge_recipes_ingredients". All fields are combined with a logical 'AND'.
"""
input bridge_recipes_ingredients_bool_exp {
  _and: [bridge_recipes_ingredients_bool_exp!]
  _ingredient_id: String_comparison_exp
  _not: bridge_recipes_ingredients_bool_exp
  _or: [bridge_recipes_ingredients_bool_exp!]
  _recipe_id: String_comparison_exp
  id: uuid_comparison_exp
  ingredients: ingredients_bool_exp
  recipes: recipes_bool_exp
}

"""
unique or primary key constraints on table "bridge_recipes_ingredients"
"""
enum bridge_recipes_ingredients_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  bridge_recipes_ingredients_pkey
}

"""
input type for inserting data into table "bridge_recipes_ingredients"
"""
input bridge_recipes_ingredients_insert_input {
  _ingredient_id: String!
  _recipe_id: String!
  id: uuid
  ingredients: ingredients_obj_rel_insert_input
  recipes: recipes_obj_rel_insert_input
}

"""aggregate max on columns"""
type bridge_recipes_ingredients_max_fields {
  _ingredient_id: String
  _recipe_id: String
  id: uuid
}

"""
order by max() on columns of table "bridge_recipes_ingredients"
"""
input bridge_recipes_ingredients_max_order_by {
  _ingredient_id: order_by
  _recipe_id: order_by
  id: order_by
}

"""aggregate min on columns"""
type bridge_recipes_ingredients_min_fields {
  _ingredient_id: String
  _recipe_id: String
  id: uuid
}

"""
order by min() on columns of table "bridge_recipes_ingredients"
"""
input bridge_recipes_ingredients_min_order_by {
  _ingredient_id: order_by
  _recipe_id: order_by
  id: order_by
}

"""
response of any mutation on the table "bridge_recipes_ingredients"
"""
type bridge_recipes_ingredients_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [bridge_recipes_ingredients!]!
}

"""
on_conflict condition type for table "bridge_recipes_ingredients"
"""
input bridge_recipes_ingredients_on_conflict {
  constraint: bridge_recipes_ingredients_constraint!
  update_columns: [bridge_recipes_ingredients_update_column!]! = []
  where: bridge_recipes_ingredients_bool_exp
}

"""
Ordering options when selecting data from "bridge_recipes_ingredients".
"""
input bridge_recipes_ingredients_order_by {
  _ingredient_id: order_by
  _recipe_id: order_by
  id: order_by
  ingredients: ingredients_order_by
  recipes: recipes_order_by
}

"""primary key columns input for table: bridge_recipes_ingredients"""
input bridge_recipes_ingredients_pk_columns_input {
  id: uuid!
}

"""
select columns of table "bridge_recipes_ingredients"
"""
enum bridge_recipes_ingredients_select_column {
  """column name"""
  _ingredient_id

  """column name"""
  _recipe_id

  """column name"""
  id
}

"""
input type for updating data in table "bridge_recipes_ingredients"
"""
input bridge_recipes_ingredients_set_input {
  _ingredient_id: String
  _recipe_id: String
  id: uuid
}

"""
Streaming cursor of the table "bridge_recipes_ingredients"
"""
input bridge_recipes_ingredients_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: bridge_recipes_ingredients_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input bridge_recipes_ingredients_stream_cursor_value_input {
  _ingredient_id: String
  _recipe_id: String
  id: uuid
}

"""
update columns of table "bridge_recipes_ingredients"
"""
enum bridge_recipes_ingredients_update_column {
  """column name"""
  _ingredient_id

  """column name"""
  _recipe_id

  """column name"""
  id
}

input bridge_recipes_ingredients_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: bridge_recipes_ingredients_set_input
  where: bridge_recipes_ingredients_bool_exp!
}

"""
columns and relationships of "bridge_recipes_tags"
"""
type bridge_recipes_tags {
  _recipe_id: String!
  _tag_id: String!
  id: uuid!

  """An object relationship"""
  recipes: recipes

  """An object relationship"""
  tags: tags
}

"""
aggregated selection of "bridge_recipes_tags"
"""
type bridge_recipes_tags_aggregate {
  aggregate: bridge_recipes_tags_aggregate_fields
  nodes: [bridge_recipes_tags!]!
}

input bridge_recipes_tags_aggregate_bool_exp {
  count: bridge_recipes_tags_aggregate_bool_exp_count
}

input bridge_recipes_tags_aggregate_bool_exp_count {
  arguments: [bridge_recipes_tags_select_column!]
  distinct: Boolean
  filter: bridge_recipes_tags_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "bridge_recipes_tags"
"""
type bridge_recipes_tags_aggregate_fields {
  count(columns: [bridge_recipes_tags_select_column!], distinct: Boolean): Int!
  max: bridge_recipes_tags_max_fields
  min: bridge_recipes_tags_min_fields
}

"""
order by aggregate values of table "bridge_recipes_tags"
"""
input bridge_recipes_tags_aggregate_order_by {
  count: order_by
  max: bridge_recipes_tags_max_order_by
  min: bridge_recipes_tags_min_order_by
}

"""
input type for inserting array relation for remote table "bridge_recipes_tags"
"""
input bridge_recipes_tags_arr_rel_insert_input {
  data: [bridge_recipes_tags_insert_input!]!

  """upsert condition"""
  on_conflict: bridge_recipes_tags_on_conflict
}

"""
Boolean expression to filter rows from the table "bridge_recipes_tags". All fields are combined with a logical 'AND'.
"""
input bridge_recipes_tags_bool_exp {
  _and: [bridge_recipes_tags_bool_exp!]
  _not: bridge_recipes_tags_bool_exp
  _or: [bridge_recipes_tags_bool_exp!]
  _recipe_id: String_comparison_exp
  _tag_id: String_comparison_exp
  id: uuid_comparison_exp
  recipes: recipes_bool_exp
  tags: tags_bool_exp
}

"""
unique or primary key constraints on table "bridge_recipes_tags"
"""
enum bridge_recipes_tags_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  bridge_recipes_tags_pkey
}

"""
input type for inserting data into table "bridge_recipes_tags"
"""
input bridge_recipes_tags_insert_input {
  _recipe_id: String!
  _tag_id: String!
  id: uuid
  recipes: recipes_obj_rel_insert_input
  tags: tags_obj_rel_insert_input
}

"""aggregate max on columns"""
type bridge_recipes_tags_max_fields {
  _recipe_id: String
  _tag_id: String
  id: uuid
}

"""
order by max() on columns of table "bridge_recipes_tags"
"""
input bridge_recipes_tags_max_order_by {
  _recipe_id: order_by
  _tag_id: order_by
  id: order_by
}

"""aggregate min on columns"""
type bridge_recipes_tags_min_fields {
  _recipe_id: String
  _tag_id: String
  id: uuid
}

"""
order by min() on columns of table "bridge_recipes_tags"
"""
input bridge_recipes_tags_min_order_by {
  _recipe_id: order_by
  _tag_id: order_by
  id: order_by
}

"""
response of any mutation on the table "bridge_recipes_tags"
"""
type bridge_recipes_tags_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [bridge_recipes_tags!]!
}

"""
on_conflict condition type for table "bridge_recipes_tags"
"""
input bridge_recipes_tags_on_conflict {
  constraint: bridge_recipes_tags_constraint!
  update_columns: [bridge_recipes_tags_update_column!]! = []
  where: bridge_recipes_tags_bool_exp
}

"""Ordering options when selecting data from "bridge_recipes_tags"."""
input bridge_recipes_tags_order_by {
  _recipe_id: order_by
  _tag_id: order_by
  id: order_by
  recipes: recipes_order_by
  tags: tags_order_by
}

"""primary key columns input for table: bridge_recipes_tags"""
input bridge_recipes_tags_pk_columns_input {
  id: uuid!
}

"""
select columns of table "bridge_recipes_tags"
"""
enum bridge_recipes_tags_select_column {
  """column name"""
  _recipe_id

  """column name"""
  _tag_id

  """column name"""
  id
}

"""
input type for updating data in table "bridge_recipes_tags"
"""
input bridge_recipes_tags_set_input {
  _recipe_id: String
  _tag_id: String
  id: uuid
}

"""
Streaming cursor of the table "bridge_recipes_tags"
"""
input bridge_recipes_tags_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: bridge_recipes_tags_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input bridge_recipes_tags_stream_cursor_value_input {
  _recipe_id: String
  _tag_id: String
  id: uuid
}

"""
update columns of table "bridge_recipes_tags"
"""
enum bridge_recipes_tags_update_column {
  """column name"""
  _recipe_id

  """column name"""
  _tag_id

  """column name"""
  id
}

input bridge_recipes_tags_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: bridge_recipes_tags_set_input
  where: bridge_recipes_tags_bool_exp!
}

"""
columns and relationships of "cuisines"
"""
type cuisines {
  """An array relationship"""
  bridge_recipes_cuisines(
    """distinct select on columns"""
    distinct_on: [bridge_recipes_cuisines_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [bridge_recipes_cuisines_order_by!]

    """filter the rows returned"""
    where: bridge_recipes_cuisines_bool_exp
  ): [bridge_recipes_cuisines!]!

  """An aggregate relationship"""
  bridge_recipes_cuisines_aggregate(
    """distinct select on columns"""
    distinct_on: [bridge_recipes_cuisines_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [bridge_recipes_cuisines_order_by!]

    """filter the rows returned"""
    where: bridge_recipes_cuisines_bool_exp
  ): bridge_recipes_cuisines_aggregate!
  iconPath: String
  id: String!
  name: String!
  slug: String!
  type: String!
}

"""
aggregated selection of "cuisines"
"""
type cuisines_aggregate {
  aggregate: cuisines_aggregate_fields
  nodes: [cuisines!]!
}

"""
aggregate fields of "cuisines"
"""
type cuisines_aggregate_fields {
  count(columns: [cuisines_select_column!], distinct: Boolean): Int!
  max: cuisines_max_fields
  min: cuisines_min_fields
}

"""
Boolean expression to filter rows from the table "cuisines". All fields are combined with a logical 'AND'.
"""
input cuisines_bool_exp {
  _and: [cuisines_bool_exp!]
  _not: cuisines_bool_exp
  _or: [cuisines_bool_exp!]
  bridge_recipes_cuisines: bridge_recipes_cuisines_bool_exp
  bridge_recipes_cuisines_aggregate: bridge_recipes_cuisines_aggregate_bool_exp
  iconPath: String_comparison_exp
  id: String_comparison_exp
  name: String_comparison_exp
  slug: String_comparison_exp
  type: String_comparison_exp
}

"""
unique or primary key constraints on table "cuisines"
"""
enum cuisines_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  cuisines_pkey
}

"""
input type for inserting data into table "cuisines"
"""
input cuisines_insert_input {
  bridge_recipes_cuisines: bridge_recipes_cuisines_arr_rel_insert_input
  iconPath: String
  id: String!
  name: String!
  slug: String!
  type: String!
}

"""aggregate max on columns"""
type cuisines_max_fields {
  iconPath: String
  id: String
  name: String
  slug: String
  type: String
}

"""aggregate min on columns"""
type cuisines_min_fields {
  iconPath: String
  id: String
  name: String
  slug: String
  type: String
}

"""
response of any mutation on the table "cuisines"
"""
type cuisines_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [cuisines!]!
}

"""
input type for inserting object relation for remote table "cuisines"
"""
input cuisines_obj_rel_insert_input {
  data: cuisines_insert_input!

  """upsert condition"""
  on_conflict: cuisines_on_conflict
}

"""
on_conflict condition type for table "cuisines"
"""
input cuisines_on_conflict {
  constraint: cuisines_constraint!
  update_columns: [cuisines_update_column!]! = []
  where: cuisines_bool_exp
}

"""Ordering options when selecting data from "cuisines"."""
input cuisines_order_by {
  bridge_recipes_cuisines_aggregate: bridge_recipes_cuisines_aggregate_order_by
  iconPath: order_by
  id: order_by
  name: order_by
  slug: order_by
  type: order_by
}

"""primary key columns input for table: cuisines"""
input cuisines_pk_columns_input {
  id: String!
}

"""
select columns of table "cuisines"
"""
enum cuisines_select_column {
  """column name"""
  iconPath

  """column name"""
  id

  """column name"""
  name

  """column name"""
  slug

  """column name"""
  type
}

"""
input type for updating data in table "cuisines"
"""
input cuisines_set_input {
  iconPath: String
  id: String
  name: String
  slug: String
  type: String
}

"""
Streaming cursor of the table "cuisines"
"""
input cuisines_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: cuisines_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input cuisines_stream_cursor_value_input {
  iconPath: String
  id: String
  name: String
  slug: String
  type: String
}

"""
update columns of table "cuisines"
"""
enum cuisines_update_column {
  """column name"""
  iconPath

  """column name"""
  id

  """column name"""
  name

  """column name"""
  slug

  """column name"""
  type
}

input cuisines_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: cuisines_set_input
  where: cuisines_bool_exp!
}

"""ordering argument of a cursor"""
enum cursor_ordering {
  """ascending ordering of the cursor"""
  ASC

  """descending ordering of the cursor"""
  DESC
}

"""
columns and relationships of "ingredient_family"
"""
type ingredient_family {
  iconPath: String
  id: String!
  name: String!
  slug: String!
  type: String!
}

"""
aggregated selection of "ingredient_family"
"""
type ingredient_family_aggregate {
  aggregate: ingredient_family_aggregate_fields
  nodes: [ingredient_family!]!
}

"""
aggregate fields of "ingredient_family"
"""
type ingredient_family_aggregate_fields {
  count(columns: [ingredient_family_select_column!], distinct: Boolean): Int!
  max: ingredient_family_max_fields
  min: ingredient_family_min_fields
}

"""
Boolean expression to filter rows from the table "ingredient_family". All fields are combined with a logical 'AND'.
"""
input ingredient_family_bool_exp {
  _and: [ingredient_family_bool_exp!]
  _not: ingredient_family_bool_exp
  _or: [ingredient_family_bool_exp!]
  iconPath: String_comparison_exp
  id: String_comparison_exp
  name: String_comparison_exp
  slug: String_comparison_exp
  type: String_comparison_exp
}

"""
unique or primary key constraints on table "ingredient_family"
"""
enum ingredient_family_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  ingredient_family_pkey
}

"""
input type for inserting data into table "ingredient_family"
"""
input ingredient_family_insert_input {
  iconPath: String
  id: String!
  name: String!
  slug: String!
  type: String!
}

"""aggregate max on columns"""
type ingredient_family_max_fields {
  iconPath: String
  id: String
  name: String
  slug: String
  type: String
}

"""aggregate min on columns"""
type ingredient_family_min_fields {
  iconPath: String
  id: String
  name: String
  slug: String
  type: String
}

"""
response of any mutation on the table "ingredient_family"
"""
type ingredient_family_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [ingredient_family!]!
}

"""
input type for inserting object relation for remote table "ingredient_family"
"""
input ingredient_family_obj_rel_insert_input {
  data: ingredient_family_insert_input!

  """upsert condition"""
  on_conflict: ingredient_family_on_conflict
}

"""
on_conflict condition type for table "ingredient_family"
"""
input ingredient_family_on_conflict {
  constraint: ingredient_family_constraint!
  update_columns: [ingredient_family_update_column!]! = []
  where: ingredient_family_bool_exp
}

"""Ordering options when selecting data from "ingredient_family"."""
input ingredient_family_order_by {
  iconPath: order_by
  id: order_by
  name: order_by
  slug: order_by
  type: order_by
}

"""primary key columns input for table: ingredient_family"""
input ingredient_family_pk_columns_input {
  id: String!
}

"""
select columns of table "ingredient_family"
"""
enum ingredient_family_select_column {
  """column name"""
  iconPath

  """column name"""
  id

  """column name"""
  name

  """column name"""
  slug

  """column name"""
  type
}

"""
input type for updating data in table "ingredient_family"
"""
input ingredient_family_set_input {
  iconPath: String
  id: String
  name: String
  slug: String
  type: String
}

"""
Streaming cursor of the table "ingredient_family"
"""
input ingredient_family_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: ingredient_family_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input ingredient_family_stream_cursor_value_input {
  iconPath: String
  id: String
  name: String
  slug: String
  type: String
}

"""
update columns of table "ingredient_family"
"""
enum ingredient_family_update_column {
  """column name"""
  iconPath

  """column name"""
  id

  """column name"""
  name

  """column name"""
  slug

  """column name"""
  type
}

input ingredient_family_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: ingredient_family_set_input
  where: ingredient_family_bool_exp!
}

"""
columns and relationships of "ingredients"
"""
type ingredients {
  _family: String!

  """An array relationship"""
  bridge_recipes_ingredients(
    """distinct select on columns"""
    distinct_on: [bridge_recipes_ingredients_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [bridge_recipes_ingredients_order_by!]

    """filter the rows returned"""
    where: bridge_recipes_ingredients_bool_exp
  ): [bridge_recipes_ingredients!]!

  """An aggregate relationship"""
  bridge_recipes_ingredients_aggregate(
    """distinct select on columns"""
    distinct_on: [bridge_recipes_ingredients_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [bridge_recipes_ingredients_order_by!]

    """filter the rows returned"""
    where: bridge_recipes_ingredients_bool_exp
  ): bridge_recipes_ingredients_aggregate!
  country: String!

  """An object relationship"""
  family: ingredient_family
  id: String!
  imagePath: String
  name: String!
  slug: String!
  type: String!
}

"""
aggregated selection of "ingredients"
"""
type ingredients_aggregate {
  aggregate: ingredients_aggregate_fields
  nodes: [ingredients!]!
}

"""
aggregate fields of "ingredients"
"""
type ingredients_aggregate_fields {
  count(columns: [ingredients_select_column!], distinct: Boolean): Int!
  max: ingredients_max_fields
  min: ingredients_min_fields
}

"""
Boolean expression to filter rows from the table "ingredients". All fields are combined with a logical 'AND'.
"""
input ingredients_bool_exp {
  _and: [ingredients_bool_exp!]
  _family: String_comparison_exp
  _not: ingredients_bool_exp
  _or: [ingredients_bool_exp!]
  bridge_recipes_ingredients: bridge_recipes_ingredients_bool_exp
  bridge_recipes_ingredients_aggregate: bridge_recipes_ingredients_aggregate_bool_exp
  country: String_comparison_exp
  family: ingredient_family_bool_exp
  id: String_comparison_exp
  imagePath: String_comparison_exp
  name: String_comparison_exp
  slug: String_comparison_exp
  type: String_comparison_exp
}

"""
unique or primary key constraints on table "ingredients"
"""
enum ingredients_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  ingredients_pkey
}

"""
input type for inserting data into table "ingredients"
"""
input ingredients_insert_input {
  _family: String
  bridge_recipes_ingredients: bridge_recipes_ingredients_arr_rel_insert_input
  country: String!
  family: ingredient_family_obj_rel_insert_input
  id: String!
  imagePath: String
  name: String!
  slug: String!
  type: String!
}

"""aggregate max on columns"""
type ingredients_max_fields {
  _family: String
  country: String
  id: String
  imagePath: String
  name: String
  slug: String
  type: String
}

"""aggregate min on columns"""
type ingredients_min_fields {
  _family: String
  country: String
  id: String
  imagePath: String
  name: String
  slug: String
  type: String
}

"""
response of any mutation on the table "ingredients"
"""
type ingredients_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [ingredients!]!
}

"""
input type for inserting object relation for remote table "ingredients"
"""
input ingredients_obj_rel_insert_input {
  data: ingredients_insert_input!

  """upsert condition"""
  on_conflict: ingredients_on_conflict
}

"""
on_conflict condition type for table "ingredients"
"""
input ingredients_on_conflict {
  constraint: ingredients_constraint!
  update_columns: [ingredients_update_column!]! = []
  where: ingredients_bool_exp
}

"""Ordering options when selecting data from "ingredients"."""
input ingredients_order_by {
  _family: order_by
  bridge_recipes_ingredients_aggregate: bridge_recipes_ingredients_aggregate_order_by
  country: order_by
  family: ingredient_family_order_by
  id: order_by
  imagePath: order_by
  name: order_by
  slug: order_by
  type: order_by
}

"""primary key columns input for table: ingredients"""
input ingredients_pk_columns_input {
  id: String!
}

"""
select columns of table "ingredients"
"""
enum ingredients_select_column {
  """column name"""
  _family

  """column name"""
  country

  """column name"""
  id

  """column name"""
  imagePath

  """column name"""
  name

  """column name"""
  slug

  """column name"""
  type
}

"""
input type for updating data in table "ingredients"
"""
input ingredients_set_input {
  _family: String
  country: String
  id: String
  imagePath: String
  name: String
  slug: String
  type: String
}

"""
Streaming cursor of the table "ingredients"
"""
input ingredients_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: ingredients_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input ingredients_stream_cursor_value_input {
  _family: String
  country: String
  id: String
  imagePath: String
  name: String
  slug: String
  type: String
}

"""
update columns of table "ingredients"
"""
enum ingredients_update_column {
  """column name"""
  _family

  """column name"""
  country

  """column name"""
  id

  """column name"""
  imagePath

  """column name"""
  name

  """column name"""
  slug

  """column name"""
  type
}

input ingredients_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: ingredients_set_input
  where: ingredients_bool_exp!
}

scalar jsonb

input jsonb_cast_exp {
  _String: String_comparison_exp
}

"""
Boolean expression to compare columns of type "jsonb". All fields are combined with logical 'AND'.
"""
input jsonb_comparison_exp {
  _cast: jsonb_cast_exp

  """is the column contained in the given json value"""
  _contained_in: jsonb

  """does the column contain the given json value at the top level"""
  _contains: jsonb
  _eq: jsonb
  _gt: jsonb
  _gte: jsonb

  """does the string exist as a top-level key in the column"""
  _has_key: String

  """do all of these strings exist as top-level keys in the column"""
  _has_keys_all: [String!]

  """do any of these strings exist as top-level keys in the column"""
  _has_keys_any: [String!]
  _in: [jsonb!]
  _is_null: Boolean
  _lt: jsonb
  _lte: jsonb
  _neq: jsonb
  _nin: [jsonb!]
}

"""mutation root"""
type mutation_root {
  """
  delete data from the table: "bridge_recipes_cuisines"
  """
  delete_bridge_recipes_cuisines(
    """filter the rows which have to be deleted"""
    where: bridge_recipes_cuisines_bool_exp!
  ): bridge_recipes_cuisines_mutation_response

  """
  delete single row from the table: "bridge_recipes_cuisines"
  """
  delete_bridge_recipes_cuisines_by_pk(id: uuid!): bridge_recipes_cuisines

  """
  delete data from the table: "bridge_recipes_ingredients"
  """
  delete_bridge_recipes_ingredients(
    """filter the rows which have to be deleted"""
    where: bridge_recipes_ingredients_bool_exp!
  ): bridge_recipes_ingredients_mutation_response

  """
  delete single row from the table: "bridge_recipes_ingredients"
  """
  delete_bridge_recipes_ingredients_by_pk(id: uuid!): bridge_recipes_ingredients

  """
  delete data from the table: "bridge_recipes_tags"
  """
  delete_bridge_recipes_tags(
    """filter the rows which have to be deleted"""
    where: bridge_recipes_tags_bool_exp!
  ): bridge_recipes_tags_mutation_response

  """
  delete single row from the table: "bridge_recipes_tags"
  """
  delete_bridge_recipes_tags_by_pk(id: uuid!): bridge_recipes_tags

  """
  delete data from the table: "cuisines"
  """
  delete_cuisines(
    """filter the rows which have to be deleted"""
    where: cuisines_bool_exp!
  ): cuisines_mutation_response

  """
  delete single row from the table: "cuisines"
  """
  delete_cuisines_by_pk(id: String!): cuisines

  """
  delete data from the table: "ingredient_family"
  """
  delete_ingredient_family(
    """filter the rows which have to be deleted"""
    where: ingredient_family_bool_exp!
  ): ingredient_family_mutation_response

  """
  delete single row from the table: "ingredient_family"
  """
  delete_ingredient_family_by_pk(id: String!): ingredient_family

  """
  delete data from the table: "ingredients"
  """
  delete_ingredients(
    """filter the rows which have to be deleted"""
    where: ingredients_bool_exp!
  ): ingredients_mutation_response

  """
  delete single row from the table: "ingredients"
  """
  delete_ingredients_by_pk(id: String!): ingredients

  """
  delete data from the table: "recipes"
  """
  delete_recipes(
    """filter the rows which have to be deleted"""
    where: recipes_bool_exp!
  ): recipes_mutation_response

  """
  delete single row from the table: "recipes"
  """
  delete_recipes_by_pk(id: String!): recipes

  """
  delete data from the table: "tags"
  """
  delete_tags(
    """filter the rows which have to be deleted"""
    where: tags_bool_exp!
  ): tags_mutation_response

  """
  delete single row from the table: "tags"
  """
  delete_tags_by_pk(id: String!): tags

  """
  insert data into the table: "bridge_recipes_cuisines"
  """
  insert_bridge_recipes_cuisines(
    """the rows to be inserted"""
    objects: [bridge_recipes_cuisines_insert_input!]!

    """upsert condition"""
    on_conflict: bridge_recipes_cuisines_on_conflict
  ): bridge_recipes_cuisines_mutation_response

  """
  insert a single row into the table: "bridge_recipes_cuisines"
  """
  insert_bridge_recipes_cuisines_one(
    """the row to be inserted"""
    object: bridge_recipes_cuisines_insert_input!

    """upsert condition"""
    on_conflict: bridge_recipes_cuisines_on_conflict
  ): bridge_recipes_cuisines

  """
  insert data into the table: "bridge_recipes_ingredients"
  """
  insert_bridge_recipes_ingredients(
    """the rows to be inserted"""
    objects: [bridge_recipes_ingredients_insert_input!]!

    """upsert condition"""
    on_conflict: bridge_recipes_ingredients_on_conflict
  ): bridge_recipes_ingredients_mutation_response

  """
  insert a single row into the table: "bridge_recipes_ingredients"
  """
  insert_bridge_recipes_ingredients_one(
    """the row to be inserted"""
    object: bridge_recipes_ingredients_insert_input!

    """upsert condition"""
    on_conflict: bridge_recipes_ingredients_on_conflict
  ): bridge_recipes_ingredients

  """
  insert data into the table: "bridge_recipes_tags"
  """
  insert_bridge_recipes_tags(
    """the rows to be inserted"""
    objects: [bridge_recipes_tags_insert_input!]!

    """upsert condition"""
    on_conflict: bridge_recipes_tags_on_conflict
  ): bridge_recipes_tags_mutation_response

  """
  insert a single row into the table: "bridge_recipes_tags"
  """
  insert_bridge_recipes_tags_one(
    """the row to be inserted"""
    object: bridge_recipes_tags_insert_input!

    """upsert condition"""
    on_conflict: bridge_recipes_tags_on_conflict
  ): bridge_recipes_tags

  """
  insert data into the table: "cuisines"
  """
  insert_cuisines(
    """the rows to be inserted"""
    objects: [cuisines_insert_input!]!

    """upsert condition"""
    on_conflict: cuisines_on_conflict
  ): cuisines_mutation_response

  """
  insert a single row into the table: "cuisines"
  """
  insert_cuisines_one(
    """the row to be inserted"""
    object: cuisines_insert_input!

    """upsert condition"""
    on_conflict: cuisines_on_conflict
  ): cuisines

  """
  insert data into the table: "ingredient_family"
  """
  insert_ingredient_family(
    """the rows to be inserted"""
    objects: [ingredient_family_insert_input!]!

    """upsert condition"""
    on_conflict: ingredient_family_on_conflict
  ): ingredient_family_mutation_response

  """
  insert a single row into the table: "ingredient_family"
  """
  insert_ingredient_family_one(
    """the row to be inserted"""
    object: ingredient_family_insert_input!

    """upsert condition"""
    on_conflict: ingredient_family_on_conflict
  ): ingredient_family

  """
  insert data into the table: "ingredients"
  """
  insert_ingredients(
    """the rows to be inserted"""
    objects: [ingredients_insert_input!]!

    """upsert condition"""
    on_conflict: ingredients_on_conflict
  ): ingredients_mutation_response

  """
  insert a single row into the table: "ingredients"
  """
  insert_ingredients_one(
    """the row to be inserted"""
    object: ingredients_insert_input!

    """upsert condition"""
    on_conflict: ingredients_on_conflict
  ): ingredients

  """
  insert data into the table: "recipes"
  """
  insert_recipes(
    """the rows to be inserted"""
    objects: [recipes_insert_input!]!

    """upsert condition"""
    on_conflict: recipes_on_conflict
  ): recipes_mutation_response

  """
  insert a single row into the table: "recipes"
  """
  insert_recipes_one(
    """the row to be inserted"""
    object: recipes_insert_input!

    """upsert condition"""
    on_conflict: recipes_on_conflict
  ): recipes

  """
  insert data into the table: "tags"
  """
  insert_tags(
    """the rows to be inserted"""
    objects: [tags_insert_input!]!

    """upsert condition"""
    on_conflict: tags_on_conflict
  ): tags_mutation_response

  """
  insert a single row into the table: "tags"
  """
  insert_tags_one(
    """the row to be inserted"""
    object: tags_insert_input!

    """upsert condition"""
    on_conflict: tags_on_conflict
  ): tags

  """
  update data of the table: "bridge_recipes_cuisines"
  """
  update_bridge_recipes_cuisines(
    """sets the columns of the filtered rows to the given values"""
    _set: bridge_recipes_cuisines_set_input

    """filter the rows which have to be updated"""
    where: bridge_recipes_cuisines_bool_exp!
  ): bridge_recipes_cuisines_mutation_response

  """
  update single row of the table: "bridge_recipes_cuisines"
  """
  update_bridge_recipes_cuisines_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: bridge_recipes_cuisines_set_input
    pk_columns: bridge_recipes_cuisines_pk_columns_input!
  ): bridge_recipes_cuisines

  """
  update multiples rows of table: "bridge_recipes_cuisines"
  """
  update_bridge_recipes_cuisines_many(
    """updates to execute, in order"""
    updates: [bridge_recipes_cuisines_updates!]!
  ): [bridge_recipes_cuisines_mutation_response]

  """
  update data of the table: "bridge_recipes_ingredients"
  """
  update_bridge_recipes_ingredients(
    """sets the columns of the filtered rows to the given values"""
    _set: bridge_recipes_ingredients_set_input

    """filter the rows which have to be updated"""
    where: bridge_recipes_ingredients_bool_exp!
  ): bridge_recipes_ingredients_mutation_response

  """
  update single row of the table: "bridge_recipes_ingredients"
  """
  update_bridge_recipes_ingredients_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: bridge_recipes_ingredients_set_input
    pk_columns: bridge_recipes_ingredients_pk_columns_input!
  ): bridge_recipes_ingredients

  """
  update multiples rows of table: "bridge_recipes_ingredients"
  """
  update_bridge_recipes_ingredients_many(
    """updates to execute, in order"""
    updates: [bridge_recipes_ingredients_updates!]!
  ): [bridge_recipes_ingredients_mutation_response]

  """
  update data of the table: "bridge_recipes_tags"
  """
  update_bridge_recipes_tags(
    """sets the columns of the filtered rows to the given values"""
    _set: bridge_recipes_tags_set_input

    """filter the rows which have to be updated"""
    where: bridge_recipes_tags_bool_exp!
  ): bridge_recipes_tags_mutation_response

  """
  update single row of the table: "bridge_recipes_tags"
  """
  update_bridge_recipes_tags_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: bridge_recipes_tags_set_input
    pk_columns: bridge_recipes_tags_pk_columns_input!
  ): bridge_recipes_tags

  """
  update multiples rows of table: "bridge_recipes_tags"
  """
  update_bridge_recipes_tags_many(
    """updates to execute, in order"""
    updates: [bridge_recipes_tags_updates!]!
  ): [bridge_recipes_tags_mutation_response]

  """
  update data of the table: "cuisines"
  """
  update_cuisines(
    """sets the columns of the filtered rows to the given values"""
    _set: cuisines_set_input

    """filter the rows which have to be updated"""
    where: cuisines_bool_exp!
  ): cuisines_mutation_response

  """
  update single row of the table: "cuisines"
  """
  update_cuisines_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: cuisines_set_input
    pk_columns: cuisines_pk_columns_input!
  ): cuisines

  """
  update multiples rows of table: "cuisines"
  """
  update_cuisines_many(
    """updates to execute, in order"""
    updates: [cuisines_updates!]!
  ): [cuisines_mutation_response]

  """
  update data of the table: "ingredient_family"
  """
  update_ingredient_family(
    """sets the columns of the filtered rows to the given values"""
    _set: ingredient_family_set_input

    """filter the rows which have to be updated"""
    where: ingredient_family_bool_exp!
  ): ingredient_family_mutation_response

  """
  update single row of the table: "ingredient_family"
  """
  update_ingredient_family_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: ingredient_family_set_input
    pk_columns: ingredient_family_pk_columns_input!
  ): ingredient_family

  """
  update multiples rows of table: "ingredient_family"
  """
  update_ingredient_family_many(
    """updates to execute, in order"""
    updates: [ingredient_family_updates!]!
  ): [ingredient_family_mutation_response]

  """
  update data of the table: "ingredients"
  """
  update_ingredients(
    """sets the columns of the filtered rows to the given values"""
    _set: ingredients_set_input

    """filter the rows which have to be updated"""
    where: ingredients_bool_exp!
  ): ingredients_mutation_response

  """
  update single row of the table: "ingredients"
  """
  update_ingredients_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: ingredients_set_input
    pk_columns: ingredients_pk_columns_input!
  ): ingredients

  """
  update multiples rows of table: "ingredients"
  """
  update_ingredients_many(
    """updates to execute, in order"""
    updates: [ingredients_updates!]!
  ): [ingredients_mutation_response]

  """
  update data of the table: "recipes"
  """
  update_recipes(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: recipes_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: recipes_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: recipes_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: recipes_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: recipes_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: recipes_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: recipes_set_input

    """filter the rows which have to be updated"""
    where: recipes_bool_exp!
  ): recipes_mutation_response

  """
  update single row of the table: "recipes"
  """
  update_recipes_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: recipes_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: recipes_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: recipes_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: recipes_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: recipes_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: recipes_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: recipes_set_input
    pk_columns: recipes_pk_columns_input!
  ): recipes

  """
  update multiples rows of table: "recipes"
  """
  update_recipes_many(
    """updates to execute, in order"""
    updates: [recipes_updates!]!
  ): [recipes_mutation_response]

  """
  update data of the table: "tags"
  """
  update_tags(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: tags_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: tags_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: tags_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: tags_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: tags_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: tags_set_input

    """filter the rows which have to be updated"""
    where: tags_bool_exp!
  ): tags_mutation_response

  """
  update single row of the table: "tags"
  """
  update_tags_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: tags_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: tags_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: tags_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: tags_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: tags_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: tags_set_input
    pk_columns: tags_pk_columns_input!
  ): tags

  """
  update multiples rows of table: "tags"
  """
  update_tags_many(
    """updates to execute, in order"""
    updates: [tags_updates!]!
  ): [tags_mutation_response]
}

"""column ordering options"""
enum order_by {
  """in ascending order, nulls last"""
  asc

  """in ascending order, nulls first"""
  asc_nulls_first

  """in ascending order, nulls last"""
  asc_nulls_last

  """in descending order, nulls first"""
  desc

  """in descending order, nulls first"""
  desc_nulls_first

  """in descending order, nulls last"""
  desc_nulls_last
}

type query_root {
  """An array relationship"""
  bridge_recipes_cuisines(
    """distinct select on columns"""
    distinct_on: [bridge_recipes_cuisines_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [bridge_recipes_cuisines_order_by!]

    """filter the rows returned"""
    where: bridge_recipes_cuisines_bool_exp
  ): [bridge_recipes_cuisines!]!

  """An aggregate relationship"""
  bridge_recipes_cuisines_aggregate(
    """distinct select on columns"""
    distinct_on: [bridge_recipes_cuisines_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [bridge_recipes_cuisines_order_by!]

    """filter the rows returned"""
    where: bridge_recipes_cuisines_bool_exp
  ): bridge_recipes_cuisines_aggregate!

  """
  fetch data from the table: "bridge_recipes_cuisines" using primary key columns
  """
  bridge_recipes_cuisines_by_pk(id: uuid!): bridge_recipes_cuisines

  """An array relationship"""
  bridge_recipes_ingredients(
    """distinct select on columns"""
    distinct_on: [bridge_recipes_ingredients_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [bridge_recipes_ingredients_order_by!]

    """filter the rows returned"""
    where: bridge_recipes_ingredients_bool_exp
  ): [bridge_recipes_ingredients!]!

  """An aggregate relationship"""
  bridge_recipes_ingredients_aggregate(
    """distinct select on columns"""
    distinct_on: [bridge_recipes_ingredients_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [bridge_recipes_ingredients_order_by!]

    """filter the rows returned"""
    where: bridge_recipes_ingredients_bool_exp
  ): bridge_recipes_ingredients_aggregate!

  """
  fetch data from the table: "bridge_recipes_ingredients" using primary key columns
  """
  bridge_recipes_ingredients_by_pk(id: uuid!): bridge_recipes_ingredients

  """An array relationship"""
  bridge_recipes_tags(
    """distinct select on columns"""
    distinct_on: [bridge_recipes_tags_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [bridge_recipes_tags_order_by!]

    """filter the rows returned"""
    where: bridge_recipes_tags_bool_exp
  ): [bridge_recipes_tags!]!

  """An aggregate relationship"""
  bridge_recipes_tags_aggregate(
    """distinct select on columns"""
    distinct_on: [bridge_recipes_tags_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [bridge_recipes_tags_order_by!]

    """filter the rows returned"""
    where: bridge_recipes_tags_bool_exp
  ): bridge_recipes_tags_aggregate!

  """
  fetch data from the table: "bridge_recipes_tags" using primary key columns
  """
  bridge_recipes_tags_by_pk(id: uuid!): bridge_recipes_tags

  """
  fetch data from the table: "cuisines"
  """
  cuisines(
    """distinct select on columns"""
    distinct_on: [cuisines_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [cuisines_order_by!]

    """filter the rows returned"""
    where: cuisines_bool_exp
  ): [cuisines!]!

  """
  fetch aggregated fields from the table: "cuisines"
  """
  cuisines_aggregate(
    """distinct select on columns"""
    distinct_on: [cuisines_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [cuisines_order_by!]

    """filter the rows returned"""
    where: cuisines_bool_exp
  ): cuisines_aggregate!

  """fetch data from the table: "cuisines" using primary key columns"""
  cuisines_by_pk(id: String!): cuisines

  """
  fetch data from the table: "ingredient_family"
  """
  ingredient_family(
    """distinct select on columns"""
    distinct_on: [ingredient_family_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [ingredient_family_order_by!]

    """filter the rows returned"""
    where: ingredient_family_bool_exp
  ): [ingredient_family!]!

  """
  fetch aggregated fields from the table: "ingredient_family"
  """
  ingredient_family_aggregate(
    """distinct select on columns"""
    distinct_on: [ingredient_family_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [ingredient_family_order_by!]

    """filter the rows returned"""
    where: ingredient_family_bool_exp
  ): ingredient_family_aggregate!

  """
  fetch data from the table: "ingredient_family" using primary key columns
  """
  ingredient_family_by_pk(id: String!): ingredient_family

  """
  fetch data from the table: "ingredients"
  """
  ingredients(
    """distinct select on columns"""
    distinct_on: [ingredients_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [ingredients_order_by!]

    """filter the rows returned"""
    where: ingredients_bool_exp
  ): [ingredients!]!

  """
  fetch aggregated fields from the table: "ingredients"
  """
  ingredients_aggregate(
    """distinct select on columns"""
    distinct_on: [ingredients_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [ingredients_order_by!]

    """filter the rows returned"""
    where: ingredients_bool_exp
  ): ingredients_aggregate!

  """fetch data from the table: "ingredients" using primary key columns"""
  ingredients_by_pk(id: String!): ingredients

  """
  fetch data from the table: "recipes"
  """
  recipes(
    """distinct select on columns"""
    distinct_on: [recipes_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [recipes_order_by!]

    """filter the rows returned"""
    where: recipes_bool_exp
  ): [recipes!]!

  """
  fetch aggregated fields from the table: "recipes"
  """
  recipes_aggregate(
    """distinct select on columns"""
    distinct_on: [recipes_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [recipes_order_by!]

    """filter the rows returned"""
    where: recipes_bool_exp
  ): recipes_aggregate!

  """fetch data from the table: "recipes" using primary key columns"""
  recipes_by_pk(id: String!): recipes

  """
  fetch data from the table: "tags"
  """
  tags(
    """distinct select on columns"""
    distinct_on: [tags_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tags_order_by!]

    """filter the rows returned"""
    where: tags_bool_exp
  ): [tags!]!

  """
  fetch aggregated fields from the table: "tags"
  """
  tags_aggregate(
    """distinct select on columns"""
    distinct_on: [tags_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tags_order_by!]

    """filter the rows returned"""
    where: tags_bool_exp
  ): tags_aggregate!

  """fetch data from the table: "tags" using primary key columns"""
  tags_by_pk(id: String!): tags
}

"""
columns and relationships of "recipes"
"""
type recipes {
  """An array relationship"""
  bridge_recipes_cuisines(
    """distinct select on columns"""
    distinct_on: [bridge_recipes_cuisines_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [bridge_recipes_cuisines_order_by!]

    """filter the rows returned"""
    where: bridge_recipes_cuisines_bool_exp
  ): [bridge_recipes_cuisines!]!

  """An aggregate relationship"""
  bridge_recipes_cuisines_aggregate(
    """distinct select on columns"""
    distinct_on: [bridge_recipes_cuisines_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [bridge_recipes_cuisines_order_by!]

    """filter the rows returned"""
    where: bridge_recipes_cuisines_bool_exp
  ): bridge_recipes_cuisines_aggregate!

  """An array relationship"""
  bridge_recipes_ingredients(
    """distinct select on columns"""
    distinct_on: [bridge_recipes_ingredients_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [bridge_recipes_ingredients_order_by!]

    """filter the rows returned"""
    where: bridge_recipes_ingredients_bool_exp
  ): [bridge_recipes_ingredients!]!

  """An aggregate relationship"""
  bridge_recipes_ingredients_aggregate(
    """distinct select on columns"""
    distinct_on: [bridge_recipes_ingredients_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [bridge_recipes_ingredients_order_by!]

    """filter the rows returned"""
    where: bridge_recipes_ingredients_bool_exp
  ): bridge_recipes_ingredients_aggregate!

  """An array relationship"""
  bridge_recipes_tags(
    """distinct select on columns"""
    distinct_on: [bridge_recipes_tags_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [bridge_recipes_tags_order_by!]

    """filter the rows returned"""
    where: bridge_recipes_tags_bool_exp
  ): [bridge_recipes_tags!]!

  """An aggregate relationship"""
  bridge_recipes_tags_aggregate(
    """distinct select on columns"""
    distinct_on: [bridge_recipes_tags_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [bridge_recipes_tags_order_by!]

    """filter the rows returned"""
    where: bridge_recipes_tags_bool_exp
  ): bridge_recipes_tags_aggregate!
  country: String!
  description: String!
  descriptionMarkdown: String
  difficulty: Int!
  headline: String!
  id: String!
  imagePath: String
  name: String!
  prepTime: String
  slug: String!
  steps(
    """JSON select path"""
    path: String
  ): jsonb
  totalTime: String
  yields_json(
    """JSON select path"""
    path: String
  ): jsonb!
}

"""
aggregated selection of "recipes"
"""
type recipes_aggregate {
  aggregate: recipes_aggregate_fields
  nodes: [recipes!]!
}

"""
aggregate fields of "recipes"
"""
type recipes_aggregate_fields {
  avg: recipes_avg_fields
  count(columns: [recipes_select_column!], distinct: Boolean): Int!
  max: recipes_max_fields
  min: recipes_min_fields
  stddev: recipes_stddev_fields
  stddev_pop: recipes_stddev_pop_fields
  stddev_samp: recipes_stddev_samp_fields
  sum: recipes_sum_fields
  var_pop: recipes_var_pop_fields
  var_samp: recipes_var_samp_fields
  variance: recipes_variance_fields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input recipes_append_input {
  steps: jsonb
  yields_json: jsonb
}

"""aggregate avg on columns"""
type recipes_avg_fields {
  difficulty: Float
}

"""
Boolean expression to filter rows from the table "recipes". All fields are combined with a logical 'AND'.
"""
input recipes_bool_exp {
  _and: [recipes_bool_exp!]
  _not: recipes_bool_exp
  _or: [recipes_bool_exp!]
  bridge_recipes_cuisines: bridge_recipes_cuisines_bool_exp
  bridge_recipes_cuisines_aggregate: bridge_recipes_cuisines_aggregate_bool_exp
  bridge_recipes_ingredients: bridge_recipes_ingredients_bool_exp
  bridge_recipes_ingredients_aggregate: bridge_recipes_ingredients_aggregate_bool_exp
  bridge_recipes_tags: bridge_recipes_tags_bool_exp
  bridge_recipes_tags_aggregate: bridge_recipes_tags_aggregate_bool_exp
  country: String_comparison_exp
  description: String_comparison_exp
  descriptionMarkdown: String_comparison_exp
  difficulty: Int_comparison_exp
  headline: String_comparison_exp
  id: String_comparison_exp
  imagePath: String_comparison_exp
  name: String_comparison_exp
  prepTime: String_comparison_exp
  slug: String_comparison_exp
  steps: jsonb_comparison_exp
  totalTime: String_comparison_exp
  yields_json: jsonb_comparison_exp
}

"""
unique or primary key constraints on table "recipes"
"""
enum recipes_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  recipes_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input recipes_delete_at_path_input {
  steps: [String!]
  yields_json: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input recipes_delete_elem_input {
  steps: Int
  yields_json: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input recipes_delete_key_input {
  steps: String
  yields_json: String
}

"""
input type for incrementing numeric columns in table "recipes"
"""
input recipes_inc_input {
  difficulty: Int
}

"""
input type for inserting data into table "recipes"
"""
input recipes_insert_input {
  bridge_recipes_cuisines: bridge_recipes_cuisines_arr_rel_insert_input
  bridge_recipes_ingredients: bridge_recipes_ingredients_arr_rel_insert_input
  bridge_recipes_tags: bridge_recipes_tags_arr_rel_insert_input
  country: String!
  description: String!
  descriptionMarkdown: String
  difficulty: Int!
  headline: String!
  id: String!
  imagePath: String
  name: String!
  prepTime: String
  slug: String!
  steps: jsonb!
  totalTime: String
  yields_json: jsonb!
}

"""aggregate max on columns"""
type recipes_max_fields {
  country: String
  description: String
  descriptionMarkdown: String
  difficulty: Int
  headline: String
  id: String
  imagePath: String
  name: String
  prepTime: String
  slug: String
  totalTime: String
}

"""aggregate min on columns"""
type recipes_min_fields {
  country: String
  description: String
  descriptionMarkdown: String
  difficulty: Int
  headline: String
  id: String
  imagePath: String
  name: String
  prepTime: String
  slug: String
  totalTime: String
}

"""
response of any mutation on the table "recipes"
"""
type recipes_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [recipes!]!
}

"""
input type for inserting object relation for remote table "recipes"
"""
input recipes_obj_rel_insert_input {
  data: recipes_insert_input!

  """upsert condition"""
  on_conflict: recipes_on_conflict
}

"""
on_conflict condition type for table "recipes"
"""
input recipes_on_conflict {
  constraint: recipes_constraint!
  update_columns: [recipes_update_column!]! = []
  where: recipes_bool_exp
}

"""Ordering options when selecting data from "recipes"."""
input recipes_order_by {
  bridge_recipes_cuisines_aggregate: bridge_recipes_cuisines_aggregate_order_by
  bridge_recipes_ingredients_aggregate: bridge_recipes_ingredients_aggregate_order_by
  bridge_recipes_tags_aggregate: bridge_recipes_tags_aggregate_order_by
  country: order_by
  description: order_by
  descriptionMarkdown: order_by
  difficulty: order_by
  headline: order_by
  id: order_by
  imagePath: order_by
  name: order_by
  prepTime: order_by
  slug: order_by
  steps: order_by
  totalTime: order_by
  yields_json: order_by
}

"""primary key columns input for table: recipes"""
input recipes_pk_columns_input {
  id: String!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input recipes_prepend_input {
  steps: jsonb
  yields_json: jsonb
}

"""
select columns of table "recipes"
"""
enum recipes_select_column {
  """column name"""
  country

  """column name"""
  description

  """column name"""
  descriptionMarkdown

  """column name"""
  difficulty

  """column name"""
  headline

  """column name"""
  id

  """column name"""
  imagePath

  """column name"""
  name

  """column name"""
  prepTime

  """column name"""
  slug

  """column name"""
  steps

  """column name"""
  totalTime

  """column name"""
  yields_json
}

"""
input type for updating data in table "recipes"
"""
input recipes_set_input {
  country: String
  description: String
  descriptionMarkdown: String
  difficulty: Int
  headline: String
  id: String
  imagePath: String
  name: String
  prepTime: String
  slug: String
  steps: jsonb
  totalTime: String
  yields_json: jsonb
}

"""aggregate stddev on columns"""
type recipes_stddev_fields {
  difficulty: Float
}

"""aggregate stddev_pop on columns"""
type recipes_stddev_pop_fields {
  difficulty: Float
}

"""aggregate stddev_samp on columns"""
type recipes_stddev_samp_fields {
  difficulty: Float
}

"""
Streaming cursor of the table "recipes"
"""
input recipes_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: recipes_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input recipes_stream_cursor_value_input {
  country: String
  description: String
  descriptionMarkdown: String
  difficulty: Int
  headline: String
  id: String
  imagePath: String
  name: String
  prepTime: String
  slug: String
  steps: jsonb
  totalTime: String
  yields_json: jsonb
}

"""aggregate sum on columns"""
type recipes_sum_fields {
  difficulty: Int
}

"""
update columns of table "recipes"
"""
enum recipes_update_column {
  """column name"""
  country

  """column name"""
  description

  """column name"""
  descriptionMarkdown

  """column name"""
  difficulty

  """column name"""
  headline

  """column name"""
  id

  """column name"""
  imagePath

  """column name"""
  name

  """column name"""
  prepTime

  """column name"""
  slug

  """column name"""
  steps

  """column name"""
  totalTime

  """column name"""
  yields_json
}

input recipes_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: recipes_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: recipes_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: recipes_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: recipes_delete_key_input

  """increments the numeric columns with given value of the filtered values"""
  _inc: recipes_inc_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: recipes_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: recipes_set_input
  where: recipes_bool_exp!
}

"""aggregate var_pop on columns"""
type recipes_var_pop_fields {
  difficulty: Float
}

"""aggregate var_samp on columns"""
type recipes_var_samp_fields {
  difficulty: Float
}

"""aggregate variance on columns"""
type recipes_variance_fields {
  difficulty: Float
}

type subscription_root {
  """An array relationship"""
  bridge_recipes_cuisines(
    """distinct select on columns"""
    distinct_on: [bridge_recipes_cuisines_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [bridge_recipes_cuisines_order_by!]

    """filter the rows returned"""
    where: bridge_recipes_cuisines_bool_exp
  ): [bridge_recipes_cuisines!]!

  """An aggregate relationship"""
  bridge_recipes_cuisines_aggregate(
    """distinct select on columns"""
    distinct_on: [bridge_recipes_cuisines_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [bridge_recipes_cuisines_order_by!]

    """filter the rows returned"""
    where: bridge_recipes_cuisines_bool_exp
  ): bridge_recipes_cuisines_aggregate!

  """
  fetch data from the table: "bridge_recipes_cuisines" using primary key columns
  """
  bridge_recipes_cuisines_by_pk(id: uuid!): bridge_recipes_cuisines

  """
  fetch data from the table in a streaming manner: "bridge_recipes_cuisines"
  """
  bridge_recipes_cuisines_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [bridge_recipes_cuisines_stream_cursor_input]!

    """filter the rows returned"""
    where: bridge_recipes_cuisines_bool_exp
  ): [bridge_recipes_cuisines!]!

  """An array relationship"""
  bridge_recipes_ingredients(
    """distinct select on columns"""
    distinct_on: [bridge_recipes_ingredients_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [bridge_recipes_ingredients_order_by!]

    """filter the rows returned"""
    where: bridge_recipes_ingredients_bool_exp
  ): [bridge_recipes_ingredients!]!

  """An aggregate relationship"""
  bridge_recipes_ingredients_aggregate(
    """distinct select on columns"""
    distinct_on: [bridge_recipes_ingredients_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [bridge_recipes_ingredients_order_by!]

    """filter the rows returned"""
    where: bridge_recipes_ingredients_bool_exp
  ): bridge_recipes_ingredients_aggregate!

  """
  fetch data from the table: "bridge_recipes_ingredients" using primary key columns
  """
  bridge_recipes_ingredients_by_pk(id: uuid!): bridge_recipes_ingredients

  """
  fetch data from the table in a streaming manner: "bridge_recipes_ingredients"
  """
  bridge_recipes_ingredients_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [bridge_recipes_ingredients_stream_cursor_input]!

    """filter the rows returned"""
    where: bridge_recipes_ingredients_bool_exp
  ): [bridge_recipes_ingredients!]!

  """An array relationship"""
  bridge_recipes_tags(
    """distinct select on columns"""
    distinct_on: [bridge_recipes_tags_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [bridge_recipes_tags_order_by!]

    """filter the rows returned"""
    where: bridge_recipes_tags_bool_exp
  ): [bridge_recipes_tags!]!

  """An aggregate relationship"""
  bridge_recipes_tags_aggregate(
    """distinct select on columns"""
    distinct_on: [bridge_recipes_tags_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [bridge_recipes_tags_order_by!]

    """filter the rows returned"""
    where: bridge_recipes_tags_bool_exp
  ): bridge_recipes_tags_aggregate!

  """
  fetch data from the table: "bridge_recipes_tags" using primary key columns
  """
  bridge_recipes_tags_by_pk(id: uuid!): bridge_recipes_tags

  """
  fetch data from the table in a streaming manner: "bridge_recipes_tags"
  """
  bridge_recipes_tags_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [bridge_recipes_tags_stream_cursor_input]!

    """filter the rows returned"""
    where: bridge_recipes_tags_bool_exp
  ): [bridge_recipes_tags!]!

  """
  fetch data from the table: "cuisines"
  """
  cuisines(
    """distinct select on columns"""
    distinct_on: [cuisines_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [cuisines_order_by!]

    """filter the rows returned"""
    where: cuisines_bool_exp
  ): [cuisines!]!

  """
  fetch aggregated fields from the table: "cuisines"
  """
  cuisines_aggregate(
    """distinct select on columns"""
    distinct_on: [cuisines_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [cuisines_order_by!]

    """filter the rows returned"""
    where: cuisines_bool_exp
  ): cuisines_aggregate!

  """fetch data from the table: "cuisines" using primary key columns"""
  cuisines_by_pk(id: String!): cuisines

  """
  fetch data from the table in a streaming manner: "cuisines"
  """
  cuisines_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [cuisines_stream_cursor_input]!

    """filter the rows returned"""
    where: cuisines_bool_exp
  ): [cuisines!]!

  """
  fetch data from the table: "ingredient_family"
  """
  ingredient_family(
    """distinct select on columns"""
    distinct_on: [ingredient_family_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [ingredient_family_order_by!]

    """filter the rows returned"""
    where: ingredient_family_bool_exp
  ): [ingredient_family!]!

  """
  fetch aggregated fields from the table: "ingredient_family"
  """
  ingredient_family_aggregate(
    """distinct select on columns"""
    distinct_on: [ingredient_family_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [ingredient_family_order_by!]

    """filter the rows returned"""
    where: ingredient_family_bool_exp
  ): ingredient_family_aggregate!

  """
  fetch data from the table: "ingredient_family" using primary key columns
  """
  ingredient_family_by_pk(id: String!): ingredient_family

  """
  fetch data from the table in a streaming manner: "ingredient_family"
  """
  ingredient_family_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [ingredient_family_stream_cursor_input]!

    """filter the rows returned"""
    where: ingredient_family_bool_exp
  ): [ingredient_family!]!

  """
  fetch data from the table: "ingredients"
  """
  ingredients(
    """distinct select on columns"""
    distinct_on: [ingredients_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [ingredients_order_by!]

    """filter the rows returned"""
    where: ingredients_bool_exp
  ): [ingredients!]!

  """
  fetch aggregated fields from the table: "ingredients"
  """
  ingredients_aggregate(
    """distinct select on columns"""
    distinct_on: [ingredients_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [ingredients_order_by!]

    """filter the rows returned"""
    where: ingredients_bool_exp
  ): ingredients_aggregate!

  """fetch data from the table: "ingredients" using primary key columns"""
  ingredients_by_pk(id: String!): ingredients

  """
  fetch data from the table in a streaming manner: "ingredients"
  """
  ingredients_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [ingredients_stream_cursor_input]!

    """filter the rows returned"""
    where: ingredients_bool_exp
  ): [ingredients!]!

  """
  fetch data from the table: "recipes"
  """
  recipes(
    """distinct select on columns"""
    distinct_on: [recipes_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [recipes_order_by!]

    """filter the rows returned"""
    where: recipes_bool_exp
  ): [recipes!]!

  """
  fetch aggregated fields from the table: "recipes"
  """
  recipes_aggregate(
    """distinct select on columns"""
    distinct_on: [recipes_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [recipes_order_by!]

    """filter the rows returned"""
    where: recipes_bool_exp
  ): recipes_aggregate!

  """fetch data from the table: "recipes" using primary key columns"""
  recipes_by_pk(id: String!): recipes

  """
  fetch data from the table in a streaming manner: "recipes"
  """
  recipes_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [recipes_stream_cursor_input]!

    """filter the rows returned"""
    where: recipes_bool_exp
  ): [recipes!]!

  """
  fetch data from the table: "tags"
  """
  tags(
    """distinct select on columns"""
    distinct_on: [tags_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tags_order_by!]

    """filter the rows returned"""
    where: tags_bool_exp
  ): [tags!]!

  """
  fetch aggregated fields from the table: "tags"
  """
  tags_aggregate(
    """distinct select on columns"""
    distinct_on: [tags_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tags_order_by!]

    """filter the rows returned"""
    where: tags_bool_exp
  ): tags_aggregate!

  """fetch data from the table: "tags" using primary key columns"""
  tags_by_pk(id: String!): tags

  """
  fetch data from the table in a streaming manner: "tags"
  """
  tags_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [tags_stream_cursor_input]!

    """filter the rows returned"""
    where: tags_bool_exp
  ): [tags!]!
}

"""
columns and relationships of "tags"
"""
type tags {
  """An array relationship"""
  bridge_recipes_tags(
    """distinct select on columns"""
    distinct_on: [bridge_recipes_tags_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [bridge_recipes_tags_order_by!]

    """filter the rows returned"""
    where: bridge_recipes_tags_bool_exp
  ): [bridge_recipes_tags!]!

  """An aggregate relationship"""
  bridge_recipes_tags_aggregate(
    """distinct select on columns"""
    distinct_on: [bridge_recipes_tags_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [bridge_recipes_tags_order_by!]

    """filter the rows returned"""
    where: bridge_recipes_tags_bool_exp
  ): bridge_recipes_tags_aggregate!
  id: String!
  name: String!
  numberOfRecipesByCountry(
    """JSON select path"""
    path: String
  ): jsonb!
  slug: String!
  type: String!
}

"""
aggregated selection of "tags"
"""
type tags_aggregate {
  aggregate: tags_aggregate_fields
  nodes: [tags!]!
}

"""
aggregate fields of "tags"
"""
type tags_aggregate_fields {
  count(columns: [tags_select_column!], distinct: Boolean): Int!
  max: tags_max_fields
  min: tags_min_fields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input tags_append_input {
  numberOfRecipesByCountry: jsonb
}

"""
Boolean expression to filter rows from the table "tags". All fields are combined with a logical 'AND'.
"""
input tags_bool_exp {
  _and: [tags_bool_exp!]
  _not: tags_bool_exp
  _or: [tags_bool_exp!]
  bridge_recipes_tags: bridge_recipes_tags_bool_exp
  bridge_recipes_tags_aggregate: bridge_recipes_tags_aggregate_bool_exp
  id: String_comparison_exp
  name: String_comparison_exp
  numberOfRecipesByCountry: jsonb_comparison_exp
  slug: String_comparison_exp
  type: String_comparison_exp
}

"""
unique or primary key constraints on table "tags"
"""
enum tags_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  tags_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input tags_delete_at_path_input {
  numberOfRecipesByCountry: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input tags_delete_elem_input {
  numberOfRecipesByCountry: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input tags_delete_key_input {
  numberOfRecipesByCountry: String
}

"""
input type for inserting data into table "tags"
"""
input tags_insert_input {
  bridge_recipes_tags: bridge_recipes_tags_arr_rel_insert_input
  id: String!
  name: String!
  numberOfRecipesByCountry: jsonb!
  slug: String!
  type: String!
}

"""aggregate max on columns"""
type tags_max_fields {
  id: String
  name: String
  slug: String
  type: String
}

"""aggregate min on columns"""
type tags_min_fields {
  id: String
  name: String
  slug: String
  type: String
}

"""
response of any mutation on the table "tags"
"""
type tags_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [tags!]!
}

"""
input type for inserting object relation for remote table "tags"
"""
input tags_obj_rel_insert_input {
  data: tags_insert_input!

  """upsert condition"""
  on_conflict: tags_on_conflict
}

"""
on_conflict condition type for table "tags"
"""
input tags_on_conflict {
  constraint: tags_constraint!
  update_columns: [tags_update_column!]! = []
  where: tags_bool_exp
}

"""Ordering options when selecting data from "tags"."""
input tags_order_by {
  bridge_recipes_tags_aggregate: bridge_recipes_tags_aggregate_order_by
  id: order_by
  name: order_by
  numberOfRecipesByCountry: order_by
  slug: order_by
  type: order_by
}

"""primary key columns input for table: tags"""
input tags_pk_columns_input {
  id: String!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input tags_prepend_input {
  numberOfRecipesByCountry: jsonb
}

"""
select columns of table "tags"
"""
enum tags_select_column {
  """column name"""
  id

  """column name"""
  name

  """column name"""
  numberOfRecipesByCountry

  """column name"""
  slug

  """column name"""
  type
}

"""
input type for updating data in table "tags"
"""
input tags_set_input {
  id: String
  name: String
  numberOfRecipesByCountry: jsonb
  slug: String
  type: String
}

"""
Streaming cursor of the table "tags"
"""
input tags_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: tags_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input tags_stream_cursor_value_input {
  id: String
  name: String
  numberOfRecipesByCountry: jsonb
  slug: String
  type: String
}

"""
update columns of table "tags"
"""
enum tags_update_column {
  """column name"""
  id

  """column name"""
  name

  """column name"""
  numberOfRecipesByCountry

  """column name"""
  slug

  """column name"""
  type
}

input tags_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: tags_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: tags_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: tags_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: tags_delete_key_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: tags_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: tags_set_input
  where: tags_bool_exp!
}

scalar uuid

"""
Boolean expression to compare columns of type "uuid". All fields are combined with logical 'AND'.
"""
input uuid_comparison_exp {
  _eq: uuid
  _gt: uuid
  _gte: uuid
  _in: [uuid!]
  _is_null: Boolean
  _lt: uuid
  _lte: uuid
  _neq: uuid
  _nin: [uuid!]
}

